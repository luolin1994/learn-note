<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>hello</h2>


    
    <script>

        //1.使用setTimeout模拟异步操作
        // setTimeout( () => {
        //     console.log('hello,world')
        // } , 1000)

        //参数是一个函数(resolve, reject)
        //resolve, reject本身又是函数
        //链式编程
        // new Promise((resolve, reject) => {

        //     //1.第一次网络请求代码
        //     setTimeout( () => {
        //         resolve()
        //     } , 1000)
        // }).then(() => {
        //     //第一次拿到结果的代码
        //     console.log('hello,world')
        //     console.log('hello,world')
        //     console.log('hello,world')
        //     console.log('hello,world')
        //     console.log('hello,world')

        //     return new Promise((resolve, reject) => {
        //         //第二次网络请求
        //         setTimeout(() => {
        //             resolve()
        //         },1000)
        //     })
        // }).then(() => {
        //     //第二次结果处理
        //     console.log('hello, vuejs');
        //     console.log('hello, vuejs');
        //     console.log('hello, vuejs');
        //     console.log('hello, vuejs');
        //     console.log('hello, vuejs');

        //     return new Promise((resolve, reject) => {
        //         //第三次网络请求
        //         setTimeout(() => {
        //             resolve()
        //     },1000)
        //     })
            

        // }).then(() => {
        //     //第三次结果处理
        //     console.log('hello, python');
        //     console.log('hello, python');
        //     console.log('hello, python');
        //     console.log('hello, python');
        //     console.log('hello, python');
        // })


        //什么情况下使用Promise？
        //一般情况下有异步操作时，使用Promise对这个异步操作进行封装
        //new -> 构造函数(1.保存状态信息 2.执行传入的函数)
        //在执行传入的回调函数时，会传入两个参数 resolve, reject本身又是函数
        //resolve内的参数就是then处理时拿到的参数
        new Promise((resolve, reject) => {
            //异步请求
            setTimeout(() => {
                //成功的时候调用resolve,来到then
                //resolve('hello,word')

                //失败的时候调用reject,来到catch
                reject('error message');
            },1000)
        }).then((data) => {
            //请求处理代码
            console.log(data);
            console.log(data);
            console.log(data);
            console.log(data);
        }).catch((error) => {
            console.log(error)
        })


    </script>
</body>
</html>